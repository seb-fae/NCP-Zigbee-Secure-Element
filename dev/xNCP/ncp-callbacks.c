// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// This callback file is created for your convenience. You may add application
// code to this file. If you regenerate this file over a previous version, the
// previous version will be overwritten and any code you have added will be
// lost.
#include <app_se.h>
#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include EMBER_AF_API_EMBER_TYPES
#include "app/util/ezsp/ezsp-enum.h"
#include "hal/hal.h"
#include "app/util/ezsp/ezsp-frame-utilities.h"
#include EMBER_AF_API_NVM3
#include EMBER_AF_API_ZIGBEE_PRO
#include EMBER_AF_API_STACK

#include <ecp.h>
#include <pk.h>
#include "mbedtls/x509_crt.h"

#define SL_SE_MESSAGE_TO_SIGN_SIZE 32

/// Challenge buffer
static uint8_t challenge_buf[SL_SE_MESSAGE_TO_SIGN_SIZE];
/// Signature buffer
static uint8_t signature_buf[SL_SE_CERT_SIGN_SIZE];
/// Certificate size buffer
static sl_se_cert_size_type_t cert_size_buf;
/// Certificate buffer
static uint8_t cert_buf[CERT_SIZE];

enum se_state state = RESET_STATE;

EmberEventControl eventData;

#define MAX_EZSP_TRANSFER_SIZE 96

uint8_t command = 0;
uint32_t sent = 0;

/***************************************************************************//**
 * Get certificate size.
 ******************************************************************************/
uint32_t get_cert_size(uint8_t cert_type)
{
  if (cert_type == SL_SE_CERT_BATCH) {
    return cert_size_buf.batch_id_size;
  } else if (cert_type == SL_SE_CERT_DEVICE_SE) {
    return cert_size_buf.se_id_size;
  } else if (cert_type == SL_SE_CERT_DEVICE_HOST) {
    return cert_size_buf.host_id_size;
  } else {
    return 0;
  }
}

/** @brief Performs any additional initialization required at system startup.
 *
 * This function is called when the application starts and can be used to
 * perform any additional initialization required at system startup.
 */
void emberAfMainInitCallback(void)
{
  RETARGET_SwoInit();
  printf("MainInitCb\n");

  if (sl_se_init() == SL_STATUS_OK)
    state = INITIALISED;
}


void eventHandler(void)
{
  emberEventControlSetInactive(eventData);
  uint8_t *p = NULL;
  uint8_t rsplen = 0;
  uint32_t var = 0;

  switch(command)
    {
      case CMD_RD_CERT_SIZE:
        var = sizeof(cert_size_buf);
        p = (uint8_t *)&cert_size_buf;
        break;
      case CMD_RD_DEVICE_CERT:
         var = get_cert_size(SL_SE_CERT_DEVICE_HOST);
         p = cert_buf;
         break;
      case CMD_RD_BATCH_CERT:
        var = get_cert_size(SL_SE_CERT_BATCH);
        p = cert_buf;
        break;
      case CMD_GENERATE_ECDH_KEYPAIR_GENERATE:
        var = ECC_PUBKEY_SIZE;
        p = get_client_buf_ptr();
        break;
      case CMD_GENERATE_ECDH_COMPUTE_SHARED:
        var = SHARED_SECRET_SIZE;
        p = get_client_shared_secret_buf_ptr();
        break;
      case CMD_SIGN_CHALLENGE:
        var = SL_SE_CERT_SIGN_SIZE;
        p = signature_buf;
        break;
      default:
        break;
    }

  p += sent;
  rsplen = (var - sent) > MAX_EZSP_TRANSFER_SIZE ? MAX_EZSP_TRANSFER_SIZE : var - sent;
  sent += rsplen;

  emberAfPluginXncpSendCustomEzspMessage(rsplen, p);

  if (rsplen % MAX_EZSP_TRANSFER_SIZE || (rsplen == 0))
    return;

  emberEventControlSetDelayMS(eventData, 10);
}


EmberStatus emberAfPluginXncpIncomingCustomFrameCallback(uint8_t messageLength,
                                                         uint8_t *messagePayload,
                                                         uint8_t *replyPayloadLength,
                                                         uint8_t *replyPayload) {
  sl_status_t status = EMBER_SUCCESS;

  if (state != INITIALISED)
  {
    status = EMBER_ERR_FATAL;
    goto error;
  }

  printf("CMD: %d\n", command);

  *replyPayloadLength = 0;
  command = messagePayload[0];
  sent = 0;

  sl_se_command_context_t *ctx = get_ctx_ptr();
  sl_se_key_descriptor_t private_device_key = SL_SE_APPLICATION_ATTESTATION_KEY;


  switch(command)
  {
    case CMD_RD_CERT_SIZE:
      status = sl_se_read_cert_size(ctx, &cert_size_buf);
      break;
    case CMD_RD_DEVICE_CERT:
      status = sl_se_read_cert(ctx, SL_SE_CERT_DEVICE_HOST, cert_buf, get_cert_size(SL_SE_CERT_DEVICE_HOST));
      break;
    case CMD_RD_BATCH_CERT:
      status = sl_se_read_cert(ctx, SL_SE_CERT_BATCH, cert_buf, get_cert_size(SL_SE_CERT_BATCH));
      break;
    case CMD_SIGN_CHALLENGE:
      memcpy(challenge_buf, messagePayload + 1, SL_SE_MESSAGE_TO_SIGN_SIZE);
      status = sl_se_ecc_sign(ctx, &private_device_key, SL_SE_HASH_NONE, true, challenge_buf, SL_SE_MESSAGE_TO_SIGN_SIZE, signature_buf, SL_SE_CERT_SIGN_SIZE);
      break;
    case CMD_GENERATE_ECDH_KEYPAIR_GENERATE:
      status = create_wrap_asymmetric_key(SL_SE_KEY_TYPE_ECC_P256, true);
      if (status)
        goto error;
      status = export_asymmetric_pubkey_from_wrap(SL_SE_KEY_TYPE_ECC_P256, true);
      break;
    case CMD_GENERATE_ECDH_COMPUTE_SHARED:
       memset(get_client_shared_secret_buf_ptr(), 0, SHARED_SECRET_SIZE);
       memcpy(get_server_buf_ptr(), messagePayload + 1, 64);
       status = compute_wrap_shared_secret(SL_SE_KEY_TYPE_ECC_P256, true);
       break;
    default:
      return EMBER_BAD_ARGUMENT;
      break;
  }

  if (status)
    goto error;

  emberEventControlSetDelayMS(eventData, 10);
  return status;

error:
  printf("Error\n");
  *replyPayloadLength = 1;
  replyPayload[0] = status;
  return EMBER_ERR_FATAL;
 }







