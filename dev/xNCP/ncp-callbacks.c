// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// This callback file is created for your convenience. You may add application
// code to this file. If you regenerate this file over a previous version, the
// previous version will be overwritten and any code you have added will be
// lost.
#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include EMBER_AF_API_EMBER_TYPES
#include "app/util/ezsp/ezsp-enum.h"
#include "hal/hal.h"
#include "app/util/ezsp/ezsp-frame-utilities.h"

#include EMBER_AF_API_NVM3
#include EMBER_AF_API_ZIGBEE_PRO
#include EMBER_AF_API_STACK

EmberEventControl eventData;

#include "x509_crt.h"
#include "ecp.h"
#include "pk.h"
#include "sl_se_manager_util.h"
#include "sl_se_manager_internal_keys.h"

/// Certificate buffer size
#define CERT_SIZE       (512)
/// Command context
static sl_se_command_context_t cmd_ctx;

/// Certificate size buffer
static sl_se_cert_size_type_t cert_size_buf;

/// Challenge buffer
static uint8_t challenge_buf[SL_SE_CHALLENGE_SIZE];

/// Certificate buffer
static uint8_t cert_buf[CERT_SIZE];

/// Public device key buffer
static uint8_t pub_device_key_buf[SL_SE_CERT_KEY_SIZE];

/// Signature buffer
static uint8_t signature_buf[SL_SE_CERT_SIGN_SIZE];

/// Number of bytes actually used in the token.
static size_t token_len;

/// Certificate chain context
static mbedtls_x509_crt cert_chain;

typedef enum {
  CMD_RD_CERT_SIZE,
  CMD_RD_DEVICE_CERT,
  CMD_RD_BATCH_CERT,
  CMD_VERIFY_CERT_CHAIN,
  CMD_SIGN_CHALLENGE,
  CMD_GET_PUBLIC_DEVICE_KEY,
  CMD_VERIFY_SIGNATURE_LOCAL,
  CMD_VERIFY_SIGNATURE_REMOTE,
} cmd_t;


enum se_state
{
  RESET_STATE,
  INITIALISED
};

enum se_state state = RESET_STATE;


/***************************************************************************//**
 * Get certificate size.
 ******************************************************************************/
uint32_t get_cert_size(uint8_t cert_type)
{
  if (cert_type == SL_SE_CERT_BATCH) {
    return cert_size_buf.batch_id_size;
  } else if (cert_type == SL_SE_CERT_DEVICE_SE) {
    return cert_size_buf.se_id_size;
  } else if (cert_type == SL_SE_CERT_DEVICE_HOST) {
    return cert_size_buf.host_id_size;
  } else {
    return 0;
  }
}
uint8_t * get_cert_buf_ptr(void)
{
  return(cert_buf);
}

uint8_t * get_pub_device_key_buf_ptr(void)
{
  return(pub_device_key_buf);
}

int32_t get_pub_device_key(void)
{
  int32_t ret;
  mbedtls_ecp_keypair ecp_key;

  // Copy public key in device certificate to an ECP key-pair structure
  mbedtls_ecp_keypair_init(&ecp_key);
  ret = mbedtls_ecp_copy(&ecp_key.Q, &mbedtls_pk_ec(cert_chain.pk)->Q);

  if (ret != 0) {
    return ret;
  }

  // Save public key X to a buffer
  ret = mbedtls_mpi_write_binary(&ecp_key.Q.X,
                                 (uint8_t *)get_pub_device_key_buf_ptr(),
                                 SL_SE_CERT_KEY_SIZE / 2);
  if (ret != 0) {
    return ret;
  }

  // Save public key Y to a buffer
  return mbedtls_mpi_write_binary(&ecp_key.Q.Y,
                                  (uint8_t *)get_pub_device_key_buf_ptr() + 32,
                                  SL_SE_CERT_KEY_SIZE / 2);
}
/** @brief Performs any additional initialization required at system startup.
 *
 * This function is called when the application starts and can be used to
 * perform any additional initialization required at system startup.
 */
void emberAfMainInitCallback(void) {
 // your code here
  if (sl_se_init() == SL_STATUS_OK)
    state = INITIALISED;
}

#define MAX_EZSP_TRANSFER_SIZE 96

uint8_t command = 0;


sl_status_t status;
uint32_t sent = 0;

void eventHandler(void)
{
  emberEventControlSetInactive(eventData);
  uint8_t *p;
  uint8_t rsplen = 0;
  uint32_t var;

  switch(command)
    {
      case CMD_RD_CERT_SIZE:
        var = sizeof(cert_size_buf);
        p = (uint8_t *)&cert_size_buf;
        break;
      case CMD_RD_DEVICE_CERT:
        var = get_cert_size(SL_SE_CERT_DEVICE_HOST);
        p = cert_buf;
        break;
      case CMD_RD_BATCH_CERT:
        var = get_cert_size(SL_SE_CERT_BATCH);
        p = cert_buf;
        break;
      case CMD_GET_PUBLIC_DEVICE_KEY:
        var = SL_SE_CERT_KEY_SIZE;
        p = (uint8_t *)get_pub_device_key_buf_ptr();
        break;
      default:
        break;
    }

  p += sent;
  rsplen = (var - sent) > MAX_EZSP_TRANSFER_SIZE ? MAX_EZSP_TRANSFER_SIZE : var - sent;
  sent += rsplen;

  emberAfPluginXncpSendCustomEzspMessage(rsplen, p);

  if (rsplen % MAX_EZSP_TRANSFER_SIZE || (rsplen == 0))
    return;

  emberEventControlSetDelayMS(eventData, 10);
}

EmberStatus emberAfPluginXncpIncomingCustomFrameCallback(uint8_t messageLength,
                                                         uint8_t *messagePayload,
                                                         uint8_t *replyPayloadLength,
                                                         uint8_t *replyPayload) {

  if (state != INITIALISED)
    return EMBER_ERR_FATAL;

  command = messagePayload[0];
  sent = 0;
  sl_status_t status;

  switch(command)
  {
    case CMD_RD_CERT_SIZE:
      status = sl_se_read_cert_size(&cmd_ctx, &cert_size_buf);
      if (status != SL_STATUS_OK)
        return EMBER_ERR_FATAL;
      emberEventControlSetDelayMS(eventData, 10);
      break;
    case CMD_RD_DEVICE_CERT:
      status = sl_se_read_cert(&cmd_ctx, SL_SE_CERT_DEVICE_HOST, cert_buf, get_cert_size(SL_SE_CERT_DEVICE_HOST));
      if (status != SL_STATUS_OK)
        return EMBER_ERR_FATAL;
      emberEventControlSetDelayMS(eventData, 10);
      break;
    case CMD_RD_BATCH_CERT:
      status = sl_se_read_cert(&cmd_ctx, SL_SE_CERT_BATCH, cert_buf, get_cert_size(SL_SE_CERT_BATCH));
      if (status != SL_STATUS_OK)
        return EMBER_ERR_FATAL;
      emberEventControlSetDelayMS(eventData, 10);
      break;
    case CMD_GET_PUBLIC_DEVICE_KEY:
      mbedtls_x509_crt_init(&cert_chain);
      mbedtls_x509_crt_parse_der(&cert_chain,(const uint8_t *)get_cert_buf_ptr(), get_cert_size(SL_SE_CERT_DEVICE_HOST));
      if (get_pub_device_key() != SL_STATUS_OK)
        return EMBER_ERR_FATAL;
      emberEventControlSetDelayMS(eventData, 10);
      *replyPayloadLength = SL_SE_CERT_KEY_SIZE;
      memcpy(replyPayload, (uint8_t *)get_pub_device_key_buf_ptr(), SL_SE_CERT_KEY_SIZE);
      break;
    case CMD_SIGN_CHALLENGE:
      {
        // Set up a key descriptor for private device key
        sl_se_key_descriptor_t private_device_key = SL_SE_APPLICATION_ATTESTATION_KEY;
        sl_se_ecc_sign(&cmd_ctx, &private_device_key, SL_SE_HASH_SHA256, false, messagePayload, messageLength, replyPayload, SL_SE_CERT_SIGN_SIZE);
        break;
      }

    default:
      return EMBER_BAD_ARGUMENT;
      break;
  }

    return EMBER_SUCCESS;

}

void emberAfMainTickCallback(void)
{
}

